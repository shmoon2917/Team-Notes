# 여행경로

## 링크

[여행경로](https://programmers.co.kr/learn/courses/30/lessons/43164#)

- 프로그래머스 Lv3

## 문제 설명

- 주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 `ICN` 공항에서 출발합니다.

- 항공권 정보가 담긴 2차원 배열 tickets가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return 하도록 solution 함수를 작성해주세요.

**제한 사항**

- 모든 공항은 알파벳 대문자 3글자로 이루어집니다.
- 주어진 공항 수는 3개 이상 10,000개 이하입니다.
- tickets의 각 행 [a, b]는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다.
- 주어진 항공권은 모두 사용해야 합니다.
- 만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다.
- 모든 도시를 방문할 수 없는 경우는 주어지지 않습니다.

**입출력 예**

|                           tickets                            |             return             |
| :----------------------------------------------------------: | :----------------------------: |
|             [[ICN, JFK], [HND, IAD], [JFK, HND]]             |      [ICN, JFK, HND, IAD]      |
| [[ICN, SFO], [ICN, ATL], [SFO, ATL], [ATL, ICN], [ATL, SFO]] | [ICN, ATL, ICN, SFO, ATL, SFO] |

**입출력 예 설명**

예제 #1

[ICN, JFK, HND, IAD] 순으로 방문할 수 있습니다.

예제 #2

[ICN, SFO, ATL, ICN, ATL, SFO] 순으로 방문할 수도 있지만 [ICN, ATL, ICN, SFO, ATL, SFO] 가 알파벳 순으로 앞섭니다.

<br></br>

## 내 풀이(DFS - 재귀함수 이용)

- 문제 해석 능력이 많이 부족함.. **테스트 케이스에서 실패뜨면 왜 실패가 뜨는지 정확히 분석해야함**

```python
answer = []
def solution(tickets):
    global answer

    tickets.sort()

    dfs(tickets, 'ICN', [])
    return answer

def dfs(tickets, start, route):
    global answer

    route.append(start)
    if len(tickets) == 1 and len(answer) == 0:
        route.append(tickets[0][1])
        answer = route

    candidates = False
    for idx, val in enumerate(tickets):
        if start == val[0]:
            candidates = True
            dfs(tickets[0:idx] + tickets[idx+1:], val[1], route[:])

    if not candidates:
        return
```

## 다른 풀이

```python
answer = []
done = False
def solution(tickets):
    tickets.sort()
    dfs('ICN', tickets, ['ICN'])
    return answer

def dfs(start, tickets, route):
    global answer, done
    if done: return

    if len(tickets) == 0:
        answer = route
        done = True
        return

    c_idx = [i for i in range(len(tickets)) if tickets[i][0] == start]

    if len(c_idx) == 0:
        return

    for idx in c_idx:
        start = tickets[idx][1]
        dfs(tickets[idx][1], tickets[:idx] + tickets[idx+1:], route + [start])
```
